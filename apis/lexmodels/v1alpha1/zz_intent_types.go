/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CodeHookObservation struct {
}

type CodeHookParameters struct {

	// +kubebuilder:validation:Required
	MessageVersion *string `json:"messageVersion" tf:"message_version,omitempty"`

	// +kubebuilder:validation:Required
	URI *string `json:"uri" tf:"uri,omitempty"`
}

type ConclusionStatementMessageObservation struct {
}

type ConclusionStatementMessageParameters struct {

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`

	// +kubebuilder:validation:Required
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// +kubebuilder:validation:Optional
	GroupNumber *float64 `json:"groupNumber,omitempty" tf:"group_number,omitempty"`
}

type ConclusionStatementObservation struct {
}

type ConclusionStatementParameters struct {

	// +kubebuilder:validation:Required
	Message []ConclusionStatementMessageParameters `json:"message" tf:"message,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card,omitempty"`
}

type ConfirmationPromptMessageObservation struct {
}

type ConfirmationPromptMessageParameters struct {

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`

	// +kubebuilder:validation:Required
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// +kubebuilder:validation:Optional
	GroupNumber *float64 `json:"groupNumber,omitempty" tf:"group_number,omitempty"`
}

type ConfirmationPromptObservation struct {
}

type ConfirmationPromptParameters struct {

	// +kubebuilder:validation:Required
	MaxAttempts *float64 `json:"maxAttempts" tf:"max_attempts,omitempty"`

	// +kubebuilder:validation:Required
	Message []ConfirmationPromptMessageParameters `json:"message" tf:"message,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card,omitempty"`
}

type DialogCodeHookObservation struct {
}

type DialogCodeHookParameters struct {

	// +kubebuilder:validation:Required
	MessageVersion *string `json:"messageVersion" tf:"message_version,omitempty"`

	// +kubebuilder:validation:Required
	URI *string `json:"uri" tf:"uri,omitempty"`
}

type FollowUpPromptObservation struct {
}

type FollowUpPromptParameters struct {

	// +kubebuilder:validation:Required
	Prompt []PromptParameters `json:"prompt" tf:"prompt,omitempty"`

	// +kubebuilder:validation:Required
	RejectionStatement []RejectionStatementParameters `json:"rejectionStatement" tf:"rejection_statement,omitempty"`
}

type FulfillmentActivityObservation struct {
}

type FulfillmentActivityParameters struct {

	// +kubebuilder:validation:Optional
	CodeHook []CodeHookParameters `json:"codeHook,omitempty" tf:"code_hook,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type IntentObservation_2 struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	Checksum *string `json:"checksum,omitempty" tf:"checksum,omitempty"`

	CreatedDate *string `json:"createdDate,omitempty" tf:"created_date,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	LastUpdatedDate *string `json:"lastUpdatedDate,omitempty" tf:"last_updated_date,omitempty"`

	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type IntentParameters_2 struct {

	// +kubebuilder:validation:Optional
	ConclusionStatement []ConclusionStatementParameters `json:"conclusionStatement,omitempty" tf:"conclusion_statement,omitempty"`

	// +kubebuilder:validation:Optional
	ConfirmationPrompt []ConfirmationPromptParameters `json:"confirmationPrompt,omitempty" tf:"confirmation_prompt,omitempty"`

	// +kubebuilder:validation:Optional
	CreateVersion *bool `json:"createVersion,omitempty" tf:"create_version,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DialogCodeHook []DialogCodeHookParameters `json:"dialogCodeHook,omitempty" tf:"dialog_code_hook,omitempty"`

	// +kubebuilder:validation:Optional
	FollowUpPrompt []FollowUpPromptParameters `json:"followUpPrompt,omitempty" tf:"follow_up_prompt,omitempty"`

	// +kubebuilder:validation:Required
	FulfillmentActivity []FulfillmentActivityParameters `json:"fulfillmentActivity" tf:"fulfillment_activity,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ParentIntentSignature *string `json:"parentIntentSignature,omitempty" tf:"parent_intent_signature,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	RejectionStatement []IntentRejectionStatementParameters `json:"rejectionStatement,omitempty" tf:"rejection_statement,omitempty"`

	// +kubebuilder:validation:Optional
	SampleUtterances []*string `json:"sampleUtterances,omitempty" tf:"sample_utterances,omitempty"`

	// +kubebuilder:validation:Optional
	Slot []SlotParameters `json:"slot,omitempty" tf:"slot,omitempty"`
}

type IntentRejectionStatementMessageObservation struct {
}

type IntentRejectionStatementMessageParameters struct {

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`

	// +kubebuilder:validation:Required
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// +kubebuilder:validation:Optional
	GroupNumber *float64 `json:"groupNumber,omitempty" tf:"group_number,omitempty"`
}

type IntentRejectionStatementObservation struct {
}

type IntentRejectionStatementParameters struct {

	// +kubebuilder:validation:Required
	Message []IntentRejectionStatementMessageParameters `json:"message" tf:"message,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card,omitempty"`
}

type PromptMessageObservation struct {
}

type PromptMessageParameters struct {

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`

	// +kubebuilder:validation:Required
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// +kubebuilder:validation:Optional
	GroupNumber *float64 `json:"groupNumber,omitempty" tf:"group_number,omitempty"`
}

type PromptObservation struct {
}

type PromptParameters struct {

	// +kubebuilder:validation:Required
	MaxAttempts *float64 `json:"maxAttempts" tf:"max_attempts,omitempty"`

	// +kubebuilder:validation:Required
	Message []PromptMessageParameters `json:"message" tf:"message,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card,omitempty"`
}

type RejectionStatementMessageObservation struct {
}

type RejectionStatementMessageParameters struct {

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`

	// +kubebuilder:validation:Required
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// +kubebuilder:validation:Optional
	GroupNumber *float64 `json:"groupNumber,omitempty" tf:"group_number,omitempty"`
}

type RejectionStatementObservation struct {
}

type RejectionStatementParameters struct {

	// +kubebuilder:validation:Required
	Message []RejectionStatementMessageParameters `json:"message" tf:"message,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card,omitempty"`
}

type SlotObservation struct {
}

type SlotParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card,omitempty"`

	// +kubebuilder:validation:Optional
	SampleUtterances []*string `json:"sampleUtterances,omitempty" tf:"sample_utterances,omitempty"`

	// +kubebuilder:validation:Required
	SlotConstraint *string `json:"slotConstraint" tf:"slot_constraint,omitempty"`

	// +kubebuilder:validation:Required
	SlotType *string `json:"slotType" tf:"slot_type,omitempty"`

	// +kubebuilder:validation:Optional
	SlotTypeVersion *string `json:"slotTypeVersion,omitempty" tf:"slot_type_version,omitempty"`

	// +kubebuilder:validation:Optional
	ValueElicitationPrompt []ValueElicitationPromptParameters `json:"valueElicitationPrompt,omitempty" tf:"value_elicitation_prompt,omitempty"`
}

type ValueElicitationPromptMessageObservation struct {
}

type ValueElicitationPromptMessageParameters struct {

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`

	// +kubebuilder:validation:Required
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// +kubebuilder:validation:Optional
	GroupNumber *float64 `json:"groupNumber,omitempty" tf:"group_number,omitempty"`
}

type ValueElicitationPromptObservation struct {
}

type ValueElicitationPromptParameters struct {

	// +kubebuilder:validation:Required
	MaxAttempts *float64 `json:"maxAttempts" tf:"max_attempts,omitempty"`

	// +kubebuilder:validation:Required
	Message []ValueElicitationPromptMessageParameters `json:"message" tf:"message,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card,omitempty"`
}

// IntentSpec defines the desired state of Intent
type IntentSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     IntentParameters_2 `json:"forProvider"`
}

// IntentStatus defines the observed state of Intent.
type IntentStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        IntentObservation_2 `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Intent is the Schema for the Intents API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,awsjet}
type Intent struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              IntentSpec   `json:"spec"`
	Status            IntentStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// IntentList contains a list of Intents
type IntentList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Intent `json:"items"`
}

// Repository type metadata.
var (
	Intent_Kind             = "Intent"
	Intent_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Intent_Kind}.String()
	Intent_KindAPIVersion   = Intent_Kind + "." + CRDGroupVersion.String()
	Intent_GroupVersionKind = CRDGroupVersion.WithKind(Intent_Kind)
)

func init() {
	SchemeBuilder.Register(&Intent{}, &IntentList{})
}
