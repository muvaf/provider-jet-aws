/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ActionForwardStickinessObservation struct {
}

type ActionForwardStickinessParameters struct {

	// +kubebuilder:validation:Required
	Duration *float64 `json:"duration" tf:"duration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ActionForwardTargetGroupObservation struct {
}

type ActionForwardTargetGroupParameters struct {

	// +kubebuilder:validation:Required
	Arn *string `json:"arn" tf:"arn,omitempty"`

	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type ConditionHTTPHeaderObservation struct {
}

type ConditionHTTPHeaderParameters struct {

	// +kubebuilder:validation:Required
	HTTPHeaderName *string `json:"httpHeaderName" tf:"http_header_name,omitempty"`

	// +kubebuilder:validation:Required
	Values []*string `json:"values" tf:"values,omitempty"`
}

type ConditionHTTPRequestMethodObservation struct {
}

type ConditionHTTPRequestMethodParameters struct {

	// +kubebuilder:validation:Required
	Values []*string `json:"values" tf:"values,omitempty"`
}

type ConditionHostHeaderObservation struct {
}

type ConditionHostHeaderParameters struct {

	// +kubebuilder:validation:Required
	Values []*string `json:"values" tf:"values,omitempty"`
}

type ConditionPathPatternObservation struct {
}

type ConditionPathPatternParameters struct {

	// +kubebuilder:validation:Required
	Values []*string `json:"values" tf:"values,omitempty"`
}

type ConditionQueryStringObservation struct {
}

type ConditionQueryStringParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type ConditionSourceIPObservation struct {
}

type ConditionSourceIPParameters struct {

	// +kubebuilder:validation:Required
	Values []*string `json:"values" tf:"values,omitempty"`
}

type LBListenerRuleActionAuthenticateCognitoObservation struct {
}

type LBListenerRuleActionAuthenticateCognitoParameters struct {

	// +kubebuilder:validation:Optional
	AuthenticationRequestExtraParams map[string]*string `json:"authenticationRequestExtraParams,omitempty" tf:"authentication_request_extra_params,omitempty"`

	// +kubebuilder:validation:Optional
	OnUnauthenticatedRequest *string `json:"onUnauthenticatedRequest,omitempty" tf:"on_unauthenticated_request,omitempty"`

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	// +kubebuilder:validation:Optional
	SessionCookieName *string `json:"sessionCookieName,omitempty" tf:"session_cookie_name,omitempty"`

	// +kubebuilder:validation:Optional
	SessionTimeout *float64 `json:"sessionTimeout,omitempty" tf:"session_timeout,omitempty"`

	// +kubebuilder:validation:Required
	UserPoolArn *string `json:"userPoolArn" tf:"user_pool_arn,omitempty"`

	// +kubebuilder:validation:Required
	UserPoolClientID *string `json:"userPoolClientId" tf:"user_pool_client_id,omitempty"`

	// +kubebuilder:validation:Required
	UserPoolDomain *string `json:"userPoolDomain" tf:"user_pool_domain,omitempty"`
}

type LBListenerRuleActionAuthenticateOidcObservation struct {
}

type LBListenerRuleActionAuthenticateOidcParameters struct {

	// +kubebuilder:validation:Optional
	AuthenticationRequestExtraParams map[string]*string `json:"authenticationRequestExtraParams,omitempty" tf:"authentication_request_extra_params,omitempty"`

	// +kubebuilder:validation:Required
	AuthorizationEndpoint *string `json:"authorizationEndpoint" tf:"authorization_endpoint,omitempty"`

	// +kubebuilder:validation:Required
	ClientID *string `json:"clientId" tf:"client_id,omitempty"`

	// +kubebuilder:validation:Required
	ClientSecretSecretRef v1.SecretKeySelector `json:"clientSecretSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	Issuer *string `json:"issuer" tf:"issuer,omitempty"`

	// +kubebuilder:validation:Optional
	OnUnauthenticatedRequest *string `json:"onUnauthenticatedRequest,omitempty" tf:"on_unauthenticated_request,omitempty"`

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	// +kubebuilder:validation:Optional
	SessionCookieName *string `json:"sessionCookieName,omitempty" tf:"session_cookie_name,omitempty"`

	// +kubebuilder:validation:Optional
	SessionTimeout *float64 `json:"sessionTimeout,omitempty" tf:"session_timeout,omitempty"`

	// +kubebuilder:validation:Required
	TokenEndpoint *string `json:"tokenEndpoint" tf:"token_endpoint,omitempty"`

	// +kubebuilder:validation:Required
	UserInfoEndpoint *string `json:"userInfoEndpoint" tf:"user_info_endpoint,omitempty"`
}

type LBListenerRuleActionFixedResponseObservation struct {
}

type LBListenerRuleActionFixedResponseParameters struct {

	// +kubebuilder:validation:Required
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// +kubebuilder:validation:Optional
	MessageBody *string `json:"messageBody,omitempty" tf:"message_body,omitempty"`

	// +kubebuilder:validation:Optional
	StatusCode *string `json:"statusCode,omitempty" tf:"status_code,omitempty"`
}

type LBListenerRuleActionForwardObservation struct {
}

type LBListenerRuleActionForwardParameters struct {

	// +kubebuilder:validation:Optional
	Stickiness []ActionForwardStickinessParameters `json:"stickiness,omitempty" tf:"stickiness,omitempty"`

	// +kubebuilder:validation:Required
	TargetGroup []ActionForwardTargetGroupParameters `json:"targetGroup" tf:"target_group,omitempty"`
}

type LBListenerRuleActionObservation struct {
}

type LBListenerRuleActionParameters struct {

	// +kubebuilder:validation:Optional
	AuthenticateCognito []LBListenerRuleActionAuthenticateCognitoParameters `json:"authenticateCognito,omitempty" tf:"authenticate_cognito,omitempty"`

	// +kubebuilder:validation:Optional
	AuthenticateOidc []LBListenerRuleActionAuthenticateOidcParameters `json:"authenticateOidc,omitempty" tf:"authenticate_oidc,omitempty"`

	// +kubebuilder:validation:Optional
	FixedResponse []LBListenerRuleActionFixedResponseParameters `json:"fixedResponse,omitempty" tf:"fixed_response,omitempty"`

	// +kubebuilder:validation:Optional
	Forward []LBListenerRuleActionForwardParameters `json:"forward,omitempty" tf:"forward,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// +kubebuilder:validation:Optional
	Redirect []LBListenerRuleActionRedirectParameters `json:"redirect,omitempty" tf:"redirect,omitempty"`

	// +kubebuilder:validation:Optional
	TargetGroupArn *string `json:"targetGroupArn,omitempty" tf:"target_group_arn,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type LBListenerRuleActionRedirectObservation struct {
}

type LBListenerRuleActionRedirectParameters struct {

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	Query *string `json:"query,omitempty" tf:"query,omitempty"`

	// +kubebuilder:validation:Required
	StatusCode *string `json:"statusCode" tf:"status_code,omitempty"`
}

type LBListenerRuleConditionObservation struct {
}

type LBListenerRuleConditionParameters struct {

	// +kubebuilder:validation:Optional
	HTTPHeader []ConditionHTTPHeaderParameters `json:"httpHeader,omitempty" tf:"http_header,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPRequestMethod []ConditionHTTPRequestMethodParameters `json:"httpRequestMethod,omitempty" tf:"http_request_method,omitempty"`

	// +kubebuilder:validation:Optional
	HostHeader []ConditionHostHeaderParameters `json:"hostHeader,omitempty" tf:"host_header,omitempty"`

	// +kubebuilder:validation:Optional
	PathPattern []ConditionPathPatternParameters `json:"pathPattern,omitempty" tf:"path_pattern,omitempty"`

	// +kubebuilder:validation:Optional
	QueryString []ConditionQueryStringParameters `json:"queryString,omitempty" tf:"query_string,omitempty"`

	// +kubebuilder:validation:Optional
	SourceIP []ConditionSourceIPParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type LBListenerRuleObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type LBListenerRuleParameters struct {

	// +kubebuilder:validation:Required
	Action []LBListenerRuleActionParameters `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Required
	Condition []LBListenerRuleConditionParameters `json:"condition" tf:"condition,omitempty"`

	// +kubebuilder:validation:Required
	ListenerArn *string `json:"listenerArn" tf:"listener_arn,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

// LBListenerRuleSpec defines the desired state of LBListenerRule
type LBListenerRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LBListenerRuleParameters `json:"forProvider"`
}

// LBListenerRuleStatus defines the observed state of LBListenerRule.
type LBListenerRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LBListenerRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LBListenerRule is the Schema for the LBListenerRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,awsjet}
type LBListenerRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LBListenerRuleSpec   `json:"spec"`
	Status            LBListenerRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LBListenerRuleList contains a list of LBListenerRules
type LBListenerRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LBListenerRule `json:"items"`
}

// Repository type metadata.
var (
	LBListenerRule_Kind             = "LBListenerRule"
	LBListenerRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LBListenerRule_Kind}.String()
	LBListenerRule_KindAPIVersion   = LBListenerRule_Kind + "." + CRDGroupVersion.String()
	LBListenerRule_GroupVersionKind = CRDGroupVersion.WithKind(LBListenerRule_Kind)
)

func init() {
	SchemeBuilder.Register(&LBListenerRule{}, &LBListenerRuleList{})
}
